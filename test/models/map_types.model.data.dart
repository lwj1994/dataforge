// Generated by data class generator
// DO NOT MODIFY BY HAND

part of 'map_types.model.dart';

mixin _MapTypes {
  abstract final Map<String, String> stringMap;
  abstract final Map<String, int> intMap;
  abstract final Map<String, double> doubleMap;
  abstract final Map<String, bool> boolMap;
  abstract final Map<String, dynamic> dynamicMap;
  abstract final Map<String, String>? optionalStringMap;
  abstract final Map<String, List<String>> listMap;
  abstract final Map<String, Map<String, String>> nestedMap;
  abstract final Map<String, String> namedMap;
  abstract final Map<String, String>? parsedMap;
  abstract final Map<String, int> customIntMap;
  abstract final Map<String, Map<String, dynamic>>? complexMap;
  abstract final List<Map<String, String>> mapList;
  abstract final Map<int, String>? intKeyMap;

  MapTypes copyWith({
    Map<String, String>? stringMap,
    Map<String, int>? intMap,
    Map<String, double>? doubleMap,
    Map<String, bool>? boolMap,
    Map<String, dynamic>? dynamicMap,
    Map<String, String>? optionalStringMap,
    Map<String, List<String>>? listMap,
    Map<String, Map<String, String>>? nestedMap,
    Map<String, String>? namedMap,
    Map<String, String>? parsedMap,
    Map<String, int>? customIntMap,
    Map<String, Map<String, dynamic>>? complexMap,
    List<Map<String, String>>? mapList,
    Map<int, String>? intKeyMap,
  }) {
    return MapTypes(
      stringMap: stringMap ?? this.stringMap,
      intMap: intMap ?? this.intMap,
      doubleMap: doubleMap ?? this.doubleMap,
      boolMap: boolMap ?? this.boolMap,
      dynamicMap: dynamicMap ?? this.dynamicMap,
      optionalStringMap: optionalStringMap ?? this.optionalStringMap,
      listMap: listMap ?? this.listMap,
      nestedMap: nestedMap ?? this.nestedMap,
      namedMap: namedMap ?? this.namedMap,
      parsedMap: parsedMap ?? this.parsedMap,
      customIntMap: customIntMap ?? this.customIntMap,
      complexMap: complexMap ?? this.complexMap,
      mapList: mapList ?? this.mapList,
      intKeyMap: intKeyMap ?? this.intKeyMap,
    );
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (other is! MapTypes) return false;

    if (!DeepCollectionEquality().equals(stringMap, other.stringMap)) {
      return false;
    }
    if (!DeepCollectionEquality().equals(intMap, other.intMap)) {
      return false;
    }
    if (!DeepCollectionEquality().equals(doubleMap, other.doubleMap)) {
      return false;
    }
    if (!DeepCollectionEquality().equals(boolMap, other.boolMap)) {
      return false;
    }
    if (!DeepCollectionEquality().equals(dynamicMap, other.dynamicMap)) {
      return false;
    }
    if (!DeepCollectionEquality()
        .equals(optionalStringMap, other.optionalStringMap)) {
      return false;
    }
    if (!DeepCollectionEquality().equals(listMap, other.listMap)) {
      return false;
    }
    if (!DeepCollectionEquality().equals(nestedMap, other.nestedMap)) {
      return false;
    }
    if (!DeepCollectionEquality().equals(namedMap, other.namedMap)) {
      return false;
    }
    if (!DeepCollectionEquality().equals(parsedMap, other.parsedMap)) {
      return false;
    }
    if (!DeepCollectionEquality().equals(customIntMap, other.customIntMap)) {
      return false;
    }
    if (!DeepCollectionEquality().equals(complexMap, other.complexMap)) {
      return false;
    }
    if (!DeepCollectionEquality().equals(mapList, other.mapList)) {
      return false;
    }
    if (!DeepCollectionEquality().equals(intKeyMap, other.intKeyMap)) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    return Object.hashAll([
      DeepCollectionEquality().hash(stringMap),
      DeepCollectionEquality().hash(intMap),
      DeepCollectionEquality().hash(doubleMap),
      DeepCollectionEquality().hash(boolMap),
      DeepCollectionEquality().hash(dynamicMap),
      DeepCollectionEquality().hash(optionalStringMap),
      DeepCollectionEquality().hash(listMap),
      DeepCollectionEquality().hash(nestedMap),
      DeepCollectionEquality().hash(namedMap),
      DeepCollectionEquality().hash(parsedMap),
      DeepCollectionEquality().hash(customIntMap),
      DeepCollectionEquality().hash(complexMap),
      DeepCollectionEquality().hash(mapList),
      DeepCollectionEquality().hash(intKeyMap),
    ]);
  }

  @override
  String toString() {
    return 'MapTypes(stringMap: $stringMap, intMap: $intMap, doubleMap: $doubleMap, boolMap: $boolMap, dynamicMap: $dynamicMap, optionalStringMap: $optionalStringMap, listMap: $listMap, nestedMap: $nestedMap, namedMap: $namedMap, parsedMap: $parsedMap, customIntMap: $customIntMap, complexMap: $complexMap, mapList: $mapList, intKeyMap: $intKeyMap)';
  }

  Map<String, dynamic> toJson() {
    final map = <String, dynamic>{};
    map['stringMap'] = stringMap;
    map['intMap'] = intMap;
    map['doubleMap'] = doubleMap;
    map['boolMap'] = boolMap;
    map['dynamicMap'] = dynamicMap;
    if (optionalStringMap != null) {
      map['optionalStringMap'] = optionalStringMap;
    }
    map['listMap'] = listMap;
    map['nestedMap'] = nestedMap;
    map['str_map'] = namedMap;
    if (parsedMap != null) {
      map['parsedMap'] = parsedMap;
    }
    map['customIntMap'] = customIntMap;
    if (complexMap != null) {
      map['complexMap'] = complexMap;
    }
    map['mapList'] = mapList;
    if (intKeyMap != null) {
      map['intKeyMap'] = intKeyMap;
    }
    return map;
  }

  static MapTypes fromJson(Map<String, dynamic> map) {
    return MapTypes(
      stringMap: (map['stringMap'] as Map<String, String>?) ?? {},
      intMap: (map['intMap'] as Map<String, int>?) ?? {},
      doubleMap: (map['doubleMap'] as Map<String, double>?) ?? {},
      boolMap: (map['boolMap'] as Map<String, bool>?) ?? {},
      dynamicMap: (map['dynamicMap'] as Map<String, dynamic>?) ?? {},
      optionalStringMap: (map['optionalStringMap'] as Map<String, String>?),
      listMap: (map['listMap'] as Map<String, List<String>>?) ?? {},
      nestedMap: (map['nestedMap'] as Map<String, Map<String, String>>?) ?? {},
      namedMap: (map['str_map'] as Map<String, String>?) ?? {},
      parsedMap: MapTypes._readValue(map, 'parsedMap') != null
          ? (MapTypes._readValue(map, 'parsedMap') as Map?)
              ?.cast<String, String>()
          : null,
      customIntMap: (MapTypes._readValue(map, 'customIntMap') as Map?)
              ?.cast<String, int>() ??
          {},
      complexMap: MapTypes._readValue(map, 'complexMap') != null
          ? (MapTypes._readValue(map, 'complexMap') as Map?)
              ?.cast<String, Map<String, dynamic>>()
          : null,
      mapList:
          (map['mapList'] as List<dynamic>?)?.cast<Map<String, String>>() ?? [],
      intKeyMap: (map['intKeyMap'] as Map<int, String>?),
    );
  }
}

mixin _MapWithObjects {
  abstract final Map<String, Address> addressMap;
  abstract final Map<String, List<Contact>> contactListMap;
  abstract final Map<String, Address>? optionalAddressMap;
  abstract final Map<String, Address>? parsedAddressMap;

  MapWithObjects copyWith({
    Map<String, Address>? addressMap,
    Map<String, List<Contact>>? contactListMap,
    Map<String, Address>? optionalAddressMap,
    Map<String, Address>? parsedAddressMap,
  }) {
    return MapWithObjects(
      addressMap: addressMap ?? this.addressMap,
      contactListMap: contactListMap ?? this.contactListMap,
      optionalAddressMap: optionalAddressMap ?? this.optionalAddressMap,
      parsedAddressMap: parsedAddressMap ?? this.parsedAddressMap,
    );
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (other is! MapWithObjects) return false;

    if (!DeepCollectionEquality().equals(addressMap, other.addressMap)) {
      return false;
    }
    if (!DeepCollectionEquality()
        .equals(contactListMap, other.contactListMap)) {
      return false;
    }
    if (!DeepCollectionEquality()
        .equals(optionalAddressMap, other.optionalAddressMap)) {
      return false;
    }
    if (!DeepCollectionEquality()
        .equals(parsedAddressMap, other.parsedAddressMap)) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    return Object.hashAll([
      DeepCollectionEquality().hash(addressMap),
      DeepCollectionEquality().hash(contactListMap),
      DeepCollectionEquality().hash(optionalAddressMap),
      DeepCollectionEquality().hash(parsedAddressMap),
    ]);
  }

  @override
  String toString() {
    return 'MapWithObjects(addressMap: $addressMap, contactListMap: $contactListMap, optionalAddressMap: $optionalAddressMap, parsedAddressMap: $parsedAddressMap)';
  }

  Map<String, dynamic> toJson() {
    final map = <String, dynamic>{};
    map['addressMap'] = addressMap;
    map['contactListMap'] = contactListMap;
    if (optionalAddressMap != null) {
      map['optionalAddressMap'] = optionalAddressMap;
    }
    if (parsedAddressMap != null) {
      map['parsedAddressMap'] = parsedAddressMap;
    }
    return map;
  }

  static MapWithObjects fromJson(Map<String, dynamic> map) {
    return MapWithObjects(
      addressMap: (map['addressMap'] as Map<String, Address>?) ?? {},
      contactListMap:
          (map['contactListMap'] as Map<String, List<Contact>>?) ?? {},
      optionalAddressMap: (map['optionalAddressMap'] as Map<String, Address>?),
      parsedAddressMap:
          MapWithObjects._readValue(map, 'parsedAddressMap') != null
              ? (MapWithObjects._readValue(map, 'parsedAddressMap') as Map?)
                  ?.cast<String, Address>()
              : null,
    );
  }
}

mixin _Address {
  abstract final String street;
  abstract final String city;
  abstract final String zipCode;

  Address copyWith({
    String? street,
    String? city,
    String? zipCode,
  }) {
    return Address(
      street: street ?? this.street,
      city: city ?? this.city,
      zipCode: zipCode ?? this.zipCode,
    );
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (other is! Address) return false;

    if (street != other.street) {
      return false;
    }
    if (city != other.city) {
      return false;
    }
    if (zipCode != other.zipCode) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    return Object.hashAll([
      street,
      city,
      zipCode,
    ]);
  }

  @override
  String toString() {
    return 'Address(street: $street, city: $city, zipCode: $zipCode)';
  }

  Map<String, dynamic> toJson() {
    final map = <String, dynamic>{};
    map['street'] = street;
    map['city'] = city;
    map['zipCode'] = zipCode;
    return map;
  }

  static Address fromJson(Map<String, dynamic> map) {
    return Address(
      street: SafeCasteUtil.safeCast<String>(map['street']) ?? "",
      city: SafeCasteUtil.safeCast<String>(map['city']) ?? "",
      zipCode: SafeCasteUtil.safeCast<String>(map['zipCode']) ?? "",
    );
  }
}

mixin _Contact {
  abstract final String email;
  abstract final String? phone;

  Contact copyWith({
    String? email,
    String? phone,
  }) {
    return Contact(
      email: email ?? this.email,
      phone: phone ?? this.phone,
    );
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (other is! Contact) return false;

    if (email != other.email) {
      return false;
    }
    if (phone != other.phone) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    return Object.hashAll([
      email,
      phone,
    ]);
  }

  @override
  String toString() {
    return 'Contact(email: $email, phone: $phone)';
  }

  Map<String, dynamic> toJson() {
    final map = <String, dynamic>{};
    map['email'] = email;
    if (phone != null) {
      map['phone'] = phone;
    }
    return map;
  }

  static Contact fromJson(Map<String, dynamic> map) {
    return Contact(
      email: SafeCasteUtil.safeCast<String>(map['email']) ?? "",
      phone: SafeCasteUtil.safeCast<String>(map['phone']),
    );
  }
}
