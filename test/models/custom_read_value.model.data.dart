// Generated by data class generator
// DO NOT MODIFY BY HAND

part of 'custom_read_value.model.dart';

mixin _CustomReadValue {
  abstract final String id;
  abstract final String name;
  abstract final String title;
  abstract final int count;
  abstract final bool enabled;
  abstract final DateTime? createdDate;
  abstract final Map<String, dynamic>? config;
  abstract final List<String>? tags;

  CustomReadValue copyWith({
    String? id,
    String? name,
    String? title,
    int? count,
    bool? enabled,
    DateTime? createdDate,
    Map<String, dynamic>? config,
    List<String>? tags,
  }) {
    return CustomReadValue(
      id: id ?? this.id,
      name: name ?? this.name,
      title: title ?? this.title,
      count: count ?? this.count,
      enabled: enabled ?? this.enabled,
      createdDate: createdDate ?? this.createdDate,
      config: config ?? this.config,
      tags: tags ?? this.tags,
    );
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (other is! CustomReadValue) return false;

    if (id != other.id) {
      return false;
    }
    if (name != other.name) {
      return false;
    }
    if (title != other.title) {
      return false;
    }
    if (count != other.count) {
      return false;
    }
    if (enabled != other.enabled) {
      return false;
    }
    if (createdDate != other.createdDate) {
      return false;
    }
    if (!DeepCollectionEquality().equals(config, other.config)) {
      return false;
    }
    if (!DeepCollectionEquality().equals(tags, other.tags)) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    return Object.hashAll([
      id,
      name,
      title,
      count,
      enabled,
      createdDate,
      DeepCollectionEquality().hash(config),
      DeepCollectionEquality().hash(tags),
    ]);
  }

  @override
  String toString() {
    return 'CustomReadValue(id: $id, name: $name, title: $title, count: $count, enabled: $enabled, createdDate: $createdDate, config: $config, tags: $tags)';
  }

  Map<String, dynamic> toJson() {
    final map = <String, dynamic>{};
    map['id'] = id;
    map['name'] = name;
    map['title'] = title;
    map['count'] = count;
    map['enabled'] = enabled;
    if (createdDate != null) {
      map['createdDate'] = createdDate != null
          ? const DateTimeConverter().toJson(createdDate!)
          : null;
    }
    if (config != null) {
      map['config'] = config;
    }
    if (tags != null) {
      map['tags'] = tags;
    }
    return map;
  }

  static CustomReadValue fromJson(Map<String, dynamic> map) {
    return CustomReadValue(
      id: SafeCasteUtil.safeCast<String>(map['id']) ?? "",
      name: SafeCasteUtil.safeCast<String>(map['name']) ?? "",
      title: SafeCasteUtil.safeCast<String>(
              CustomReadValue._readValue(map, 'title')) ??
          '',
      count: SafeCasteUtil.safeCast<int>(
              CustomReadValue._readValue(map, 'count')) ??
          0,
      enabled: SafeCasteUtil.safeCast<bool>(
              CustomReadValue._readValue(map, 'enabled')) ??
          false,
      createdDate: CustomReadValue._readValue(map, 'createdDate') != null
          ? DateTime.tryParse(
              CustomReadValue._readValue(map, 'createdDate').toString())
          : null,
      config: CustomReadValue._readValue(map, 'config') != null
          ? (CustomReadValue._readValue(map, 'config') as Map?)
              ?.cast<String, dynamic>()
          : null,
      tags: CustomReadValue._readValue(map, 'tags') != null
          ? (CustomReadValue._readValue(map, 'tags') as List?)?.cast<String>()
          : null,
    );
  }
}
