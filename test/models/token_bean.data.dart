// Generated by data class generator
// DO NOT MODIFY BY HAND

part of 'token_bean.dart';

mixin _TokenBean {
  abstract final String accessToken;
  abstract final String refreshToken;
  abstract final DateTime expiresAt;
  abstract final String tokenType;

  _TokenBeanCopyWith get copyWith => _TokenBeanCopyWith._(this as TokenBean);

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (other is! TokenBean) return false;

    if (accessToken != other.accessToken) {
      return false;
    }
    if (refreshToken != other.refreshToken) {
      return false;
    }
    if (expiresAt != other.expiresAt) {
      return false;
    }
    if (tokenType != other.tokenType) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    return Object.hashAll([
      accessToken,
      refreshToken,
      expiresAt,
      tokenType,
    ]);
  }

  @override
  String toString() {
    return 'TokenBean(accessToken: $accessToken, refreshToken: $refreshToken, expiresAt: $expiresAt, tokenType: $tokenType)';
  }

  Map<String, dynamic> toJson() {
    final map = <String, dynamic>{};
    map['accessToken'] = accessToken;
    map['refreshToken'] = refreshToken;
    map['expiresAt'] = const DefaultDateTimeConverter().toJson(expiresAt);
    map['tokenType'] = tokenType;
    return map;
  }

  static TokenBean fromJson(Map<String, dynamic> map) {
    return TokenBean(
      accessToken: SafeCasteUtil.safeCast<String>(map['accessToken']) ?? "",
      refreshToken: SafeCasteUtil.safeCast<String>(map['refreshToken']) ?? "",
      expiresAt: map['expiresAt'] != null
          ? const DefaultDateTimeConverter().fromJson(map['expiresAt'])
              as DateTime
          : throw ArgumentError('Required field expiresAt is missing'),
      tokenType: SafeCasteUtil.safeCast<String>(map['tokenType']) ?? "",
    );
  }
}

mixin _TokenMetadata {
  abstract final String issuer;
  abstract final List<String> scopes;
  abstract final Map<String, dynamic> claims;

  _TokenMetadataCopyWith get copyWith =>
      _TokenMetadataCopyWith._(this as TokenMetadata);

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (other is! TokenMetadata) return false;

    if (issuer != other.issuer) {
      return false;
    }
    if (!DeepCollectionEquality().equals(scopes, other.scopes)) {
      return false;
    }
    if (!DeepCollectionEquality().equals(claims, other.claims)) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    return Object.hashAll([
      issuer,
      DeepCollectionEquality().hash(scopes),
      DeepCollectionEquality().hash(claims),
    ]);
  }

  @override
  String toString() {
    return 'TokenMetadata(issuer: $issuer, scopes: $scopes, claims: $claims)';
  }

  Map<String, dynamic> toJson() {
    final map = <String, dynamic>{};
    map['issuer'] = issuer;
    map['scopes'] = scopes;
    map['claims'] = claims;
    return map;
  }

  static TokenMetadata fromJson(Map<String, dynamic> map) {
    return TokenMetadata(
      issuer: SafeCasteUtil.safeCast<String>(map['issuer']) ?? "",
      scopes: ((map['scopes'] as List<dynamic>?) ?? [])
          .map((e) => e.toString())
          .toList(),
      claims: (map['claims'] as Map<String, dynamic>?) ?? {},
    );
  }
}

/// Helper class for chained copyWith operations
class _TokenBeanCopyWith {
  final TokenBean _instance;
  const _TokenBeanCopyWith._(this._instance);

  /// Update accessToken field
  _TokenBeanCopyWith accessToken(String value) {
    return _TokenBeanCopyWith._(TokenBean(
      accessToken: value,
      refreshToken: _instance.refreshToken,
      expiresAt: _instance.expiresAt,
      tokenType: _instance.tokenType,
    ));
  }

  /// Update refreshToken field
  _TokenBeanCopyWith refreshToken(String value) {
    return _TokenBeanCopyWith._(TokenBean(
      accessToken: _instance.accessToken,
      refreshToken: value,
      expiresAt: _instance.expiresAt,
      tokenType: _instance.tokenType,
    ));
  }

  /// Update expiresAt field
  _TokenBeanCopyWith expiresAt(DateTime value) {
    return _TokenBeanCopyWith._(TokenBean(
      accessToken: _instance.accessToken,
      refreshToken: _instance.refreshToken,
      expiresAt: value,
      tokenType: _instance.tokenType,
    ));
  }

  /// Update tokenType field
  _TokenBeanCopyWith tokenType(String value) {
    return _TokenBeanCopyWith._(TokenBean(
      accessToken: _instance.accessToken,
      refreshToken: _instance.refreshToken,
      expiresAt: _instance.expiresAt,
      tokenType: value,
    ));
  }

  /// Build the final instance
  TokenBean build() {
    return _instance;
  }

  /// Traditional copyWith method
  TokenBean call({
    String? accessToken,
    String? refreshToken,
    DateTime? expiresAt,
    String? tokenType,
  }) {
    return TokenBean(
      accessToken: accessToken ?? _instance.accessToken,
      refreshToken: refreshToken ?? _instance.refreshToken,
      expiresAt: expiresAt ?? _instance.expiresAt,
      tokenType: tokenType ?? _instance.tokenType,
    );
  }
}

/// Helper class for chained copyWith operations
class _TokenMetadataCopyWith {
  final TokenMetadata _instance;
  const _TokenMetadataCopyWith._(this._instance);

  /// Update issuer field
  _TokenMetadataCopyWith issuer(String value) {
    return _TokenMetadataCopyWith._(TokenMetadata(
      issuer: value,
      scopes: _instance.scopes,
      claims: _instance.claims,
    ));
  }

  /// Update scopes field
  _TokenMetadataCopyWith scopes(List<String> value) {
    return _TokenMetadataCopyWith._(TokenMetadata(
      issuer: _instance.issuer,
      scopes: value,
      claims: _instance.claims,
    ));
  }

  /// Update claims field
  _TokenMetadataCopyWith claims(Map<String, dynamic> value) {
    return _TokenMetadataCopyWith._(TokenMetadata(
      issuer: _instance.issuer,
      scopes: _instance.scopes,
      claims: value,
    ));
  }

  /// Build the final instance
  TokenMetadata build() {
    return _instance;
  }

  /// Traditional copyWith method
  TokenMetadata call({
    String? issuer,
    List<String>? scopes,
    Map<String, dynamic>? claims,
  }) {
    return TokenMetadata(
      issuer: issuer ?? _instance.issuer,
      scopes: scopes ?? _instance.scopes,
      claims: claims ?? _instance.claims,
    );
  }
}
