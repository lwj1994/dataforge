// Generated by data class generator
// DO NOT MODIFY BY HAND

part of 'datetime_types.model.dart';

mixin _DateTimeTypes {
  abstract final DateTime createdAt;
  abstract final DateTime? updatedAt;
  abstract final DateTime birthDate;
  abstract final List<DateTime> eventDates;
  abstract final List<DateTime>? optionalEventDates;
  abstract final Map<String, DateTime> namedDates;
  abstract final DateTime? isoDateTime;
  abstract final DateTime timestampDate;
  abstract final DateTime? parsedDate;
  abstract final List<DateTime>? dateTimeList;
  abstract final Duration? duration;
  abstract final Duration? customDuration;

  DateTimeTypes copyWith({
    DateTime? createdAt,
    DateTime? updatedAt,
    DateTime? birthDate,
    List<DateTime>? eventDates,
    List<DateTime>? optionalEventDates,
    Map<String, DateTime>? namedDates,
    DateTime? isoDateTime,
    DateTime? timestampDate,
    DateTime? parsedDate,
    List<DateTime>? dateTimeList,
    Duration? duration,
    Duration? customDuration,
  }) {
    return DateTimeTypes(
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
      birthDate: birthDate ?? this.birthDate,
      eventDates: eventDates ?? this.eventDates,
      optionalEventDates: optionalEventDates ?? this.optionalEventDates,
      namedDates: namedDates ?? this.namedDates,
      isoDateTime: isoDateTime ?? this.isoDateTime,
      timestampDate: timestampDate ?? this.timestampDate,
      parsedDate: parsedDate ?? this.parsedDate,
      dateTimeList: dateTimeList ?? this.dateTimeList,
      duration: duration ?? this.duration,
      customDuration: customDuration ?? this.customDuration,
    );
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (other is! DateTimeTypes) return false;

    if (createdAt != other.createdAt) {
      return false;
    }
    if (updatedAt != other.updatedAt) {
      return false;
    }
    if (birthDate != other.birthDate) {
      return false;
    }
    if (!const DeepCollectionEquality().equals(eventDates, other.eventDates)) {
      return false;
    }
    if (!const DeepCollectionEquality().equals(optionalEventDates, other.optionalEventDates)) {
      return false;
    }
    if (!const DeepCollectionEquality().equals(namedDates, other.namedDates)) {
      return false;
    }
    if (isoDateTime != other.isoDateTime) {
      return false;
    }
    if (timestampDate != other.timestampDate) {
      return false;
    }
    if (parsedDate != other.parsedDate) {
      return false;
    }
    if (!const DeepCollectionEquality().equals(dateTimeList, other.dateTimeList)) {
      return false;
    }
    if (duration != other.duration) {
      return false;
    }
    if (customDuration != other.customDuration) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    return Object.hashAll([
      createdAt,
      updatedAt,
      birthDate,
      const DeepCollectionEquality().hash(eventDates),
      const DeepCollectionEquality().hash(optionalEventDates),
      const DeepCollectionEquality().hash(namedDates),
      isoDateTime,
      timestampDate,
      parsedDate,
      const DeepCollectionEquality().hash(dateTimeList),
      duration,
      customDuration,
    ]);
  }
  @override
  String toString() {
    return 'DateTimeTypes(createdAt: $createdAt, updatedAt: $updatedAt, birthDate: $birthDate, eventDates: $eventDates, optionalEventDates: $optionalEventDates, namedDates: $namedDates, isoDateTime: $isoDateTime, timestampDate: $timestampDate, parsedDate: $parsedDate, dateTimeList: $dateTimeList, duration: $duration, customDuration: $customDuration)';
  }


  Map<String, dynamic> toJson() {
    final map = <String, dynamic>{};
    map['createdAt'] = createdAt;
    map['updatedAt'] = updatedAt;
    map['birth_date'] = birthDate;
    map['eventDates'] = eventDates;
    map['optionalEventDates'] = optionalEventDates;
    map['namedDates'] = namedDates;
    map['isoDateTime'] = isoDateTime;
    map['timestampDate'] = timestampDate;
    map['parsedDate'] = parsedDate;
    map['dateTimeList'] = dateTimeList;
    map['duration'] = duration;
    map['customDuration'] = customDuration;
    return map;
  }

  static DateTimeTypes fromJson(Map<String, dynamic> map) {
    return DateTimeTypes(
      createdAt: DateTime.parse((map['createdAt'] ?? '').toString()),
      updatedAt: map['updatedAt'] != null ? DateTime.tryParse(map['updatedAt'].toString()) : null,
      birthDate: DateTime.parse((map['birth_date'] ?? '').toString()),
      eventDates: (map['eventDates'] as List<dynamic>?)?.cast<DateTime>() ?? [],
      optionalEventDates: (map['optionalEventDates'] as List<dynamic>?)?.cast<DateTime>(),
      namedDates: (map['namedDates'] as Map<String, DateTime>?) ?? {},
      isoDateTime: DateTimeTypes._readValue(map, 'isoDateTime') != null ? DateTime.tryParse(DateTimeTypes._readValue(map, 'isoDateTime').toString()) : null,
      timestampDate: DateTime.parse((DateTimeTypes._readValue(map, 'timestampDate') ?? '').toString()),
      parsedDate: DateTimeTypes._readValue(map, 'parsedDate') != null ? DateTime.tryParse(DateTimeTypes._readValue(map, 'parsedDate').toString()) : null,
      dateTimeList: DateTimeTypes._readValue(map, 'dateTimeList') as List<DateTime>?,
      duration: map['duration'] != null ? Duration(milliseconds: map['duration'] as int? ?? 0) : null,
      customDuration: DateTimeTypes._readValue(map, 'customDuration') != null ? Duration(milliseconds: DateTimeTypes._readValue(map, 'customDuration') as int? ?? 0) : null,
    );
  }
}

mixin _TimeZoneTest {
  abstract final DateTime utcTime;
  abstract final DateTime localTime;
  abstract final DateTime? timeZoneAware;
  abstract final List<DateTime> timeList;

  TimeZoneTest copyWith({
    DateTime? utcTime,
    DateTime? localTime,
    DateTime? timeZoneAware,
    List<DateTime>? timeList,
  }) {
    return TimeZoneTest(
      utcTime: utcTime ?? this.utcTime,
      localTime: localTime ?? this.localTime,
      timeZoneAware: timeZoneAware ?? this.timeZoneAware,
      timeList: timeList ?? this.timeList,
    );
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (other is! TimeZoneTest) return false;

    if (utcTime != other.utcTime) {
      return false;
    }
    if (localTime != other.localTime) {
      return false;
    }
    if (timeZoneAware != other.timeZoneAware) {
      return false;
    }
    if (!const DeepCollectionEquality().equals(timeList, other.timeList)) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    return Object.hashAll([
      utcTime,
      localTime,
      timeZoneAware,
      const DeepCollectionEquality().hash(timeList),
    ]);
  }
  @override
  String toString() {
    return 'TimeZoneTest(utcTime: $utcTime, localTime: $localTime, timeZoneAware: $timeZoneAware, timeList: $timeList)';
  }


  Map<String, dynamic> toJson() {
    final map = <String, dynamic>{};
    map['utcTime'] = utcTime;
    map['localTime'] = localTime;
    map['timeZoneAware'] = timeZoneAware;
    map['timeList'] = timeList;
    return map;
  }

  static TimeZoneTest fromJson(Map<String, dynamic> map) {
    return TimeZoneTest(
      utcTime: DateTime.parse((map['utcTime'] ?? '').toString()),
      localTime: DateTime.parse((map['localTime'] ?? '').toString()),
      timeZoneAware: TimeZoneTest._readValue(map, 'timeZoneAware') != null ? DateTime.tryParse(TimeZoneTest._readValue(map, 'timeZoneAware').toString()) : null,
      timeList: (map['timeList'] as List<dynamic>?)?.cast<DateTime>() ?? [],
    );
  }
}

