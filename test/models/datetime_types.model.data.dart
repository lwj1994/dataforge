// Generated by data class generator
// DO NOT MODIFY BY HAND

part of 'datetime_types.model.dart';

mixin _DateTimeTypes {
  abstract final DateTime createdAt;
  abstract final DateTime? updatedAt;
  abstract final DateTime birthDate;
  abstract final List<DateTime> eventDates;
  abstract final List<DateTime>? optionalEventDates;
  abstract final Map<String, DateTime> namedDates;
  abstract final DateTime? isoDateTime;
  abstract final DateTime timestampDate;
  abstract final DateTime? parsedDate;
  abstract final List<DateTime>? dateTimeList;
  abstract final Duration? duration;
  abstract final Duration? customDuration;

  _DateTimeTypesCopyWith get copyWith => _DateTimeTypesCopyWith._(this);

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (other is! DateTimeTypes) return false;

    if (createdAt != other.createdAt) {
      return false;
    }
    if (updatedAt != other.updatedAt) {
      return false;
    }
    if (birthDate != other.birthDate) {
      return false;
    }
    if (!DeepCollectionEquality().equals(eventDates, other.eventDates)) {
      return false;
    }
    if (!DeepCollectionEquality()
        .equals(optionalEventDates, other.optionalEventDates)) {
      return false;
    }
    if (!DeepCollectionEquality().equals(namedDates, other.namedDates)) {
      return false;
    }
    if (isoDateTime != other.isoDateTime) {
      return false;
    }
    if (timestampDate != other.timestampDate) {
      return false;
    }
    if (parsedDate != other.parsedDate) {
      return false;
    }
    if (!DeepCollectionEquality().equals(dateTimeList, other.dateTimeList)) {
      return false;
    }
    if (duration != other.duration) {
      return false;
    }
    if (customDuration != other.customDuration) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    return Object.hashAll([
      createdAt,
      updatedAt,
      birthDate,
      DeepCollectionEquality().hash(eventDates),
      DeepCollectionEquality().hash(optionalEventDates),
      DeepCollectionEquality().hash(namedDates),
      isoDateTime,
      timestampDate,
      parsedDate,
      DeepCollectionEquality().hash(dateTimeList),
      duration,
      customDuration,
    ]);
  }

  @override
  String toString() {
    return 'DateTimeTypes(createdAt: $createdAt, updatedAt: $updatedAt, birthDate: $birthDate, eventDates: $eventDates, optionalEventDates: $optionalEventDates, namedDates: $namedDates, isoDateTime: $isoDateTime, timestampDate: $timestampDate, parsedDate: $parsedDate, dateTimeList: $dateTimeList, duration: $duration, customDuration: $customDuration)';
  }

  Map<String, dynamic> toJson() {
    final map = <String, dynamic>{};
    map['createdAt'] = const DateTimeConverter().toJson(createdAt);
    if (updatedAt != null) {
      map['updatedAt'] = updatedAt != null
          ? const DateTimeConverter().toJson(updatedAt!)
          : null;
    }
    map['birth_date'] = const DateTimeConverter().toJson(birthDate);
    map['eventDates'] = eventDates;
    if (optionalEventDates != null) {
      map['optionalEventDates'] = optionalEventDates;
    }
    map['namedDates'] = namedDates;
    if (isoDateTime != null) {
      map['isoDateTime'] = isoDateTime != null
          ? const DateTimeConverter().toJson(isoDateTime!)
          : null;
    }
    map['timestampDate'] = const DateTimeConverter().toJson(timestampDate);
    if (parsedDate != null) {
      map['parsedDate'] = parsedDate != null
          ? const DateTimeConverter().toJson(parsedDate!)
          : null;
    }
    if (dateTimeList != null) {
      map['dateTimeList'] = dateTimeList;
    }
    if (duration != null) {
      map['duration'] =
          duration != null ? const DurationConverter().toJson(duration!) : null;
    }
    if (customDuration != null) {
      map['customDuration'] = customDuration != null
          ? const DurationConverter().toJson(customDuration!)
          : null;
    }
    return map;
  }

  static DateTimeTypes fromJson(Map<String, dynamic> map) {
    return DateTimeTypes(
      createdAt: map['createdAt'] != null
          ? const DateTimeConverter().fromJson(map['createdAt'])
          : throw ArgumentError('Required field createdAt is missing'),
      updatedAt: map['updatedAt'] != null
          ? const DateTimeConverter().fromJson(map['updatedAt'])
          : null,
      birthDate: map['birth_date'] != null
          ? const DateTimeConverter().fromJson(map['birth_date'])
          : throw ArgumentError('Required field birthDate is missing'),
      eventDates: (map['eventDates'] as List<dynamic>?)?.cast<DateTime>() ?? [],
      optionalEventDates:
          (map['optionalEventDates'] as List<dynamic>?)?.cast<DateTime>(),
      namedDates: (map['namedDates'] as Map<String, DateTime>?) ?? {},
      isoDateTime: DateTimeTypes._readValue(map, 'isoDateTime') != null
          ? DateTime.tryParse(
              DateTimeTypes._readValue(map, 'isoDateTime').toString())
          : null,
      timestampDate: DateTime.parse(
          (DateTimeTypes._readValue(map, 'timestampDate') ?? '').toString()),
      parsedDate: DateTimeTypes._readValue(map, 'parsedDate') != null
          ? DateTime.tryParse(
              DateTimeTypes._readValue(map, 'parsedDate').toString())
          : null,
      dateTimeList: DateTimeTypes._readValue(map, 'dateTimeList') != null
          ? (DateTimeTypes._readValue(map, 'dateTimeList') as List?)
              ?.cast<DateTime>()
          : null,
      duration: map['duration'] != null
          ? const DurationConverter().fromJson(map['duration'])
          : null,
      customDuration: DateTimeTypes._readValue(map, 'customDuration') != null
          ? Duration(
              milliseconds:
                  DateTimeTypes._readValue(map, 'customDuration') as int? ?? 0)
          : null,
    );
  }
}

mixin _TimeZoneTest {
  abstract final DateTime utcTime;
  abstract final DateTime localTime;
  abstract final DateTime? timeZoneAware;
  abstract final List<DateTime> timeList;

  _TimeZoneTestCopyWith get copyWith => _TimeZoneTestCopyWith._(this);

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (other is! TimeZoneTest) return false;

    if (utcTime != other.utcTime) {
      return false;
    }
    if (localTime != other.localTime) {
      return false;
    }
    if (timeZoneAware != other.timeZoneAware) {
      return false;
    }
    if (!DeepCollectionEquality().equals(timeList, other.timeList)) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    return Object.hashAll([
      utcTime,
      localTime,
      timeZoneAware,
      DeepCollectionEquality().hash(timeList),
    ]);
  }

  @override
  String toString() {
    return 'TimeZoneTest(utcTime: $utcTime, localTime: $localTime, timeZoneAware: $timeZoneAware, timeList: $timeList)';
  }

  Map<String, dynamic> toJson() {
    final map = <String, dynamic>{};
    map['utcTime'] = const DateTimeConverter().toJson(utcTime);
    map['localTime'] = const DateTimeConverter().toJson(localTime);
    if (timeZoneAware != null) {
      map['timeZoneAware'] = timeZoneAware != null
          ? const DateTimeConverter().toJson(timeZoneAware!)
          : null;
    }
    map['timeList'] = timeList;
    return map;
  }

  static TimeZoneTest fromJson(Map<String, dynamic> map) {
    return TimeZoneTest(
      utcTime: map['utcTime'] != null
          ? const DateTimeConverter().fromJson(map['utcTime'])
          : throw ArgumentError('Required field utcTime is missing'),
      localTime: map['localTime'] != null
          ? const DateTimeConverter().fromJson(map['localTime'])
          : throw ArgumentError('Required field localTime is missing'),
      timeZoneAware: TimeZoneTest._readValue(map, 'timeZoneAware') != null
          ? DateTime.tryParse(
              TimeZoneTest._readValue(map, 'timeZoneAware').toString())
          : null,
      timeList: (map['timeList'] as List<dynamic>?)?.cast<DateTime>() ?? [],
    );
  }
}

/// Helper class for chained copyWith operations
class _DateTimeTypesCopyWith {
  final _DateTimeTypes _instance;
  const _DateTimeTypesCopyWith._(this._instance);

  /// Update createdAt field
  DateTimeTypes createdAt(DateTime? value) {
    return DateTimeTypes(
      createdAt: value ?? _instance.createdAt,
      updatedAt: _instance.updatedAt,
      birthDate: _instance.birthDate,
      eventDates: _instance.eventDates,
      optionalEventDates: _instance.optionalEventDates,
      namedDates: _instance.namedDates,
      isoDateTime: _instance.isoDateTime,
      timestampDate: _instance.timestampDate,
      parsedDate: _instance.parsedDate,
      dateTimeList: _instance.dateTimeList,
      duration: _instance.duration,
      customDuration: _instance.customDuration,
    );
  }

  /// Update updatedAt field
  DateTimeTypes updatedAt(DateTime? value) {
    return DateTimeTypes(
      createdAt: _instance.createdAt,
      updatedAt: value,
      birthDate: _instance.birthDate,
      eventDates: _instance.eventDates,
      optionalEventDates: _instance.optionalEventDates,
      namedDates: _instance.namedDates,
      isoDateTime: _instance.isoDateTime,
      timestampDate: _instance.timestampDate,
      parsedDate: _instance.parsedDate,
      dateTimeList: _instance.dateTimeList,
      duration: _instance.duration,
      customDuration: _instance.customDuration,
    );
  }

  /// Update birthDate field
  DateTimeTypes birthDate(DateTime? value) {
    return DateTimeTypes(
      createdAt: _instance.createdAt,
      updatedAt: _instance.updatedAt,
      birthDate: value ?? _instance.birthDate,
      eventDates: _instance.eventDates,
      optionalEventDates: _instance.optionalEventDates,
      namedDates: _instance.namedDates,
      isoDateTime: _instance.isoDateTime,
      timestampDate: _instance.timestampDate,
      parsedDate: _instance.parsedDate,
      dateTimeList: _instance.dateTimeList,
      duration: _instance.duration,
      customDuration: _instance.customDuration,
    );
  }

  /// Update eventDates field
  DateTimeTypes eventDates(List<DateTime>? value) {
    return DateTimeTypes(
      createdAt: _instance.createdAt,
      updatedAt: _instance.updatedAt,
      birthDate: _instance.birthDate,
      eventDates: value ?? _instance.eventDates,
      optionalEventDates: _instance.optionalEventDates,
      namedDates: _instance.namedDates,
      isoDateTime: _instance.isoDateTime,
      timestampDate: _instance.timestampDate,
      parsedDate: _instance.parsedDate,
      dateTimeList: _instance.dateTimeList,
      duration: _instance.duration,
      customDuration: _instance.customDuration,
    );
  }

  /// Update optionalEventDates field
  DateTimeTypes optionalEventDates(List<DateTime>? value) {
    return DateTimeTypes(
      createdAt: _instance.createdAt,
      updatedAt: _instance.updatedAt,
      birthDate: _instance.birthDate,
      eventDates: _instance.eventDates,
      optionalEventDates: value,
      namedDates: _instance.namedDates,
      isoDateTime: _instance.isoDateTime,
      timestampDate: _instance.timestampDate,
      parsedDate: _instance.parsedDate,
      dateTimeList: _instance.dateTimeList,
      duration: _instance.duration,
      customDuration: _instance.customDuration,
    );
  }

  /// Update namedDates field
  DateTimeTypes namedDates(Map<String, DateTime>? value) {
    return DateTimeTypes(
      createdAt: _instance.createdAt,
      updatedAt: _instance.updatedAt,
      birthDate: _instance.birthDate,
      eventDates: _instance.eventDates,
      optionalEventDates: _instance.optionalEventDates,
      namedDates: value ?? _instance.namedDates,
      isoDateTime: _instance.isoDateTime,
      timestampDate: _instance.timestampDate,
      parsedDate: _instance.parsedDate,
      dateTimeList: _instance.dateTimeList,
      duration: _instance.duration,
      customDuration: _instance.customDuration,
    );
  }

  /// Update isoDateTime field
  DateTimeTypes isoDateTime(DateTime? value) {
    return DateTimeTypes(
      createdAt: _instance.createdAt,
      updatedAt: _instance.updatedAt,
      birthDate: _instance.birthDate,
      eventDates: _instance.eventDates,
      optionalEventDates: _instance.optionalEventDates,
      namedDates: _instance.namedDates,
      isoDateTime: value,
      timestampDate: _instance.timestampDate,
      parsedDate: _instance.parsedDate,
      dateTimeList: _instance.dateTimeList,
      duration: _instance.duration,
      customDuration: _instance.customDuration,
    );
  }

  /// Update timestampDate field
  DateTimeTypes timestampDate(DateTime? value) {
    return DateTimeTypes(
      createdAt: _instance.createdAt,
      updatedAt: _instance.updatedAt,
      birthDate: _instance.birthDate,
      eventDates: _instance.eventDates,
      optionalEventDates: _instance.optionalEventDates,
      namedDates: _instance.namedDates,
      isoDateTime: _instance.isoDateTime,
      timestampDate: value ?? _instance.timestampDate,
      parsedDate: _instance.parsedDate,
      dateTimeList: _instance.dateTimeList,
      duration: _instance.duration,
      customDuration: _instance.customDuration,
    );
  }

  /// Update parsedDate field
  DateTimeTypes parsedDate(DateTime? value) {
    return DateTimeTypes(
      createdAt: _instance.createdAt,
      updatedAt: _instance.updatedAt,
      birthDate: _instance.birthDate,
      eventDates: _instance.eventDates,
      optionalEventDates: _instance.optionalEventDates,
      namedDates: _instance.namedDates,
      isoDateTime: _instance.isoDateTime,
      timestampDate: _instance.timestampDate,
      parsedDate: value,
      dateTimeList: _instance.dateTimeList,
      duration: _instance.duration,
      customDuration: _instance.customDuration,
    );
  }

  /// Update dateTimeList field
  DateTimeTypes dateTimeList(List<DateTime>? value) {
    return DateTimeTypes(
      createdAt: _instance.createdAt,
      updatedAt: _instance.updatedAt,
      birthDate: _instance.birthDate,
      eventDates: _instance.eventDates,
      optionalEventDates: _instance.optionalEventDates,
      namedDates: _instance.namedDates,
      isoDateTime: _instance.isoDateTime,
      timestampDate: _instance.timestampDate,
      parsedDate: _instance.parsedDate,
      dateTimeList: value,
      duration: _instance.duration,
      customDuration: _instance.customDuration,
    );
  }

  /// Update duration field
  DateTimeTypes duration(Duration? value) {
    return DateTimeTypes(
      createdAt: _instance.createdAt,
      updatedAt: _instance.updatedAt,
      birthDate: _instance.birthDate,
      eventDates: _instance.eventDates,
      optionalEventDates: _instance.optionalEventDates,
      namedDates: _instance.namedDates,
      isoDateTime: _instance.isoDateTime,
      timestampDate: _instance.timestampDate,
      parsedDate: _instance.parsedDate,
      dateTimeList: _instance.dateTimeList,
      duration: value,
      customDuration: _instance.customDuration,
    );
  }

  /// Update customDuration field
  DateTimeTypes customDuration(Duration? value) {
    return DateTimeTypes(
      createdAt: _instance.createdAt,
      updatedAt: _instance.updatedAt,
      birthDate: _instance.birthDate,
      eventDates: _instance.eventDates,
      optionalEventDates: _instance.optionalEventDates,
      namedDates: _instance.namedDates,
      isoDateTime: _instance.isoDateTime,
      timestampDate: _instance.timestampDate,
      parsedDate: _instance.parsedDate,
      dateTimeList: _instance.dateTimeList,
      duration: _instance.duration,
      customDuration: value,
    );
  }

  /// Traditional copyWith method
  DateTimeTypes call({
    DateTime? createdAt,
    DateTime? updatedAt,
    DateTime? birthDate,
    List<DateTime>? eventDates,
    List<DateTime>? optionalEventDates,
    Map<String, DateTime>? namedDates,
    DateTime? isoDateTime,
    DateTime? timestampDate,
    DateTime? parsedDate,
    List<DateTime>? dateTimeList,
    Duration? duration,
    Duration? customDuration,
  }) {
    return DateTimeTypes(
      createdAt: createdAt ?? _instance.createdAt,
      updatedAt: updatedAt ?? _instance.updatedAt,
      birthDate: birthDate ?? _instance.birthDate,
      eventDates: eventDates ?? _instance.eventDates,
      optionalEventDates: optionalEventDates ?? _instance.optionalEventDates,
      namedDates: namedDates ?? _instance.namedDates,
      isoDateTime: isoDateTime ?? _instance.isoDateTime,
      timestampDate: timestampDate ?? _instance.timestampDate,
      parsedDate: parsedDate ?? _instance.parsedDate,
      dateTimeList: dateTimeList ?? _instance.dateTimeList,
      duration: duration ?? _instance.duration,
      customDuration: customDuration ?? _instance.customDuration,
    );
  }
}

/// Helper class for chained copyWith operations
class _TimeZoneTestCopyWith {
  final _TimeZoneTest _instance;
  const _TimeZoneTestCopyWith._(this._instance);

  /// Update utcTime field
  TimeZoneTest utcTime(DateTime? value) {
    return TimeZoneTest(
      utcTime: value ?? _instance.utcTime,
      localTime: _instance.localTime,
      timeZoneAware: _instance.timeZoneAware,
      timeList: _instance.timeList,
    );
  }

  /// Update localTime field
  TimeZoneTest localTime(DateTime? value) {
    return TimeZoneTest(
      utcTime: _instance.utcTime,
      localTime: value ?? _instance.localTime,
      timeZoneAware: _instance.timeZoneAware,
      timeList: _instance.timeList,
    );
  }

  /// Update timeZoneAware field
  TimeZoneTest timeZoneAware(DateTime? value) {
    return TimeZoneTest(
      utcTime: _instance.utcTime,
      localTime: _instance.localTime,
      timeZoneAware: value,
      timeList: _instance.timeList,
    );
  }

  /// Update timeList field
  TimeZoneTest timeList(List<DateTime>? value) {
    return TimeZoneTest(
      utcTime: _instance.utcTime,
      localTime: _instance.localTime,
      timeZoneAware: _instance.timeZoneAware,
      timeList: value ?? _instance.timeList,
    );
  }

  /// Traditional copyWith method
  TimeZoneTest call({
    DateTime? utcTime,
    DateTime? localTime,
    DateTime? timeZoneAware,
    List<DateTime>? timeList,
  }) {
    return TimeZoneTest(
      utcTime: utcTime ?? _instance.utcTime,
      localTime: localTime ?? _instance.localTime,
      timeZoneAware: timeZoneAware ?? _instance.timeZoneAware,
      timeList: timeList ?? _instance.timeList,
    );
  }
}
