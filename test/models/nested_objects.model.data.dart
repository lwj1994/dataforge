// Generated by data class generator
// DO NOT MODIFY BY HAND

part of 'nested_objects.model.dart';

mixin _Address {
  abstract final String street;
  abstract final String city;
  abstract final String? state;
  abstract final String zipCode;
  abstract final String country;
  abstract final bool isPrimary;

  Address copyWith({
    String? street,
    String? city,
    String? state,
    String? zipCode,
    String? country,
    bool? isPrimary,
  }) {
    return Address(
      street: street ?? this.street,
      city: city ?? this.city,
      state: state ?? this.state,
      zipCode: zipCode ?? this.zipCode,
      country: country ?? this.country,
      isPrimary: isPrimary ?? this.isPrimary,
    );
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (other is! Address) return false;

    if (street != other.street) {
      return false;
    }
    if (city != other.city) {
      return false;
    }
    if (state != other.state) {
      return false;
    }
    if (zipCode != other.zipCode) {
      return false;
    }
    if (country != other.country) {
      return false;
    }
    if (isPrimary != other.isPrimary) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    return Object.hashAll([
      street,
      city,
      state,
      zipCode,
      country,
      isPrimary,
    ]);
  }

  @override
  String toString() {
    return 'Address(street: $street, city: $city, state: $state, zipCode: $zipCode, country: $country, isPrimary: $isPrimary)';
  }

  Map<String, dynamic> toJson() {
    final map = <String, dynamic>{};
    map['street'] = street;
    map['city'] = city;
    if (state != null) {
      map['state'] = state;
    }
    map['zipCode'] = zipCode;
    map['country'] = country;
    map['is_primary'] = isPrimary;
    return map;
  }

  static Address fromJson(Map<String, dynamic> map) {
    return Address(
      street: (map['street'])?.toString() ?? "",
      city: (map['city'])?.toString() ?? "",
      state: (map['state'])?.toString(),
      zipCode: (map['zipCode'])?.toString() ?? "",
      country: (map['country'])?.toString() ?? "",
      isPrimary: (map['is_primary'] as bool?) ?? false,
    );
  }
}

mixin _Contact {
  abstract final String email;
  abstract final String? phone;
  abstract final String contactType;

  Contact copyWith({
    String? email,
    String? phone,
    String? contactType,
  }) {
    return Contact(
      email: email ?? this.email,
      phone: phone ?? this.phone,
      contactType: contactType ?? this.contactType,
    );
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (other is! Contact) return false;

    if (email != other.email) {
      return false;
    }
    if (phone != other.phone) {
      return false;
    }
    if (contactType != other.contactType) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    return Object.hashAll([
      email,
      phone,
      contactType,
    ]);
  }

  @override
  String toString() {
    return 'Contact(email: $email, phone: $phone, contactType: $contactType)';
  }

  Map<String, dynamic> toJson() {
    final map = <String, dynamic>{};
    map['email'] = email;
    if (phone != null) {
      map['phone'] = phone;
    }
    map['contact_type'] = contactType;
    return map;
  }

  static Contact fromJson(Map<String, dynamic> map) {
    return Contact(
      email: (map['email'])?.toString() ?? "",
      phone: (map['phone'])?.toString(),
      contactType: (map['contact_type'])?.toString() ?? "",
    );
  }
}

mixin _Company {
  abstract final String name;
  abstract final Address headquarters;
  abstract final List<Address>? branches;
  abstract final Contact primaryContact;
  abstract final List<Contact>? additionalContacts;

  Company copyWith({
    String? name,
    Address? headquarters,
    List<Address>? branches,
    Contact? primaryContact,
    List<Contact>? additionalContacts,
  }) {
    return Company(
      name: name ?? this.name,
      headquarters: headquarters ?? this.headquarters,
      branches: branches ?? this.branches,
      primaryContact: primaryContact ?? this.primaryContact,
      additionalContacts: additionalContacts ?? this.additionalContacts,
    );
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (other is! Company) return false;

    if (name != other.name) {
      return false;
    }
    if (headquarters != other.headquarters) {
      return false;
    }
    if (!DeepCollectionEquality().equals(branches, other.branches)) {
      return false;
    }
    if (primaryContact != other.primaryContact) {
      return false;
    }
    if (!DeepCollectionEquality()
        .equals(additionalContacts, other.additionalContacts)) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    return Object.hashAll([
      name,
      headquarters,
      DeepCollectionEquality().hash(branches),
      primaryContact,
      DeepCollectionEquality().hash(additionalContacts),
    ]);
  }

  @override
  String toString() {
    return 'Company(name: $name, headquarters: $headquarters, branches: $branches, primaryContact: $primaryContact, additionalContacts: $additionalContacts)';
  }

  Map<String, dynamic> toJson() {
    final map = <String, dynamic>{};
    map['name'] = name;
    map['headquarters'] = headquarters;
    if (branches != null) {
      map['branches'] = branches;
    }
    map['primaryContact'] = primaryContact;
    if (additionalContacts != null) {
      map['additionalContacts'] = additionalContacts;
    }
    return map;
  }

  static Company fromJson(Map<String, dynamic> map) {
    return Company(
      name: (map['name'])?.toString() ?? "",
      headquarters:
          Address.fromJson((map['headquarters'] ?? {}) as Map<String, dynamic>),
      branches: (map['branches'] as List<dynamic>?)
          ?.map((e) => Address.fromJson(e as Map<String, dynamic>))
          .toList()
          .cast<Address>(),
      primaryContact: Contact.fromJson(
          (map['primaryContact'] ?? {}) as Map<String, dynamic>),
      additionalContacts: (map['additionalContacts'] as List<dynamic>?)
          ?.map((e) => Contact.fromJson(e as Map<String, dynamic>))
          .toList()
          .cast<Contact>(),
    );
  }
}

mixin _NestedObjects {
  abstract final String name;
  abstract final Address homeAddress;
  abstract final Address? workAddress;
  abstract final List<Address> previousAddresses;
  abstract final Map<String, Address>? namedAddresses;
  abstract final Contact primaryContact;
  abstract final List<Contact>? contacts;
  abstract final Company? employer;
  abstract final Address? customAddress;
  abstract final List<Contact>? parsedContacts;

  NestedObjects copyWith({
    String? name,
    Address? homeAddress,
    Address? workAddress,
    List<Address>? previousAddresses,
    Map<String, Address>? namedAddresses,
    Contact? primaryContact,
    List<Contact>? contacts,
    Company? employer,
    Address? customAddress,
    List<Contact>? parsedContacts,
  }) {
    return NestedObjects(
      name: name ?? this.name,
      homeAddress: homeAddress ?? this.homeAddress,
      workAddress: workAddress ?? this.workAddress,
      previousAddresses: previousAddresses ?? this.previousAddresses,
      namedAddresses: namedAddresses ?? this.namedAddresses,
      primaryContact: primaryContact ?? this.primaryContact,
      contacts: contacts ?? this.contacts,
      employer: employer ?? this.employer,
      customAddress: customAddress ?? this.customAddress,
      parsedContacts: parsedContacts ?? this.parsedContacts,
    );
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (other is! NestedObjects) return false;

    if (name != other.name) {
      return false;
    }
    if (homeAddress != other.homeAddress) {
      return false;
    }
    if (workAddress != other.workAddress) {
      return false;
    }
    if (!DeepCollectionEquality()
        .equals(previousAddresses, other.previousAddresses)) {
      return false;
    }
    if (!DeepCollectionEquality()
        .equals(namedAddresses, other.namedAddresses)) {
      return false;
    }
    if (primaryContact != other.primaryContact) {
      return false;
    }
    if (!DeepCollectionEquality().equals(contacts, other.contacts)) {
      return false;
    }
    if (employer != other.employer) {
      return false;
    }
    if (customAddress != other.customAddress) {
      return false;
    }
    if (!DeepCollectionEquality()
        .equals(parsedContacts, other.parsedContacts)) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    return Object.hashAll([
      name,
      homeAddress,
      workAddress,
      DeepCollectionEquality().hash(previousAddresses),
      DeepCollectionEquality().hash(namedAddresses),
      primaryContact,
      DeepCollectionEquality().hash(contacts),
      employer,
      customAddress,
      DeepCollectionEquality().hash(parsedContacts),
    ]);
  }

  @override
  String toString() {
    return 'NestedObjects(name: $name, homeAddress: $homeAddress, workAddress: $workAddress, previousAddresses: $previousAddresses, namedAddresses: $namedAddresses, primaryContact: $primaryContact, contacts: $contacts, employer: $employer, customAddress: $customAddress, parsedContacts: $parsedContacts)';
  }

  Map<String, dynamic> toJson() {
    final map = <String, dynamic>{};
    map['name'] = name;
    map['homeAddress'] = homeAddress;
    if (workAddress != null) {
      map['workAddress'] = workAddress;
    }
    map['previousAddresses'] = previousAddresses;
    if (namedAddresses != null) {
      map['namedAddresses'] = namedAddresses;
    }
    map['primaryContact'] = primaryContact;
    if (contacts != null) {
      map['contacts'] = contacts;
    }
    if (employer != null) {
      map['employer'] = employer;
    }
    if (customAddress != null) {
      map['customAddress'] = customAddress;
    }
    if (parsedContacts != null) {
      map['parsedContacts'] = parsedContacts;
    }
    return map;
  }

  static NestedObjects fromJson(Map<String, dynamic> map) {
    return NestedObjects(
      name: (map['name'])?.toString() ?? "",
      homeAddress:
          Address.fromJson((map['homeAddress'] ?? {}) as Map<String, dynamic>),
      workAddress: map['workAddress'] != null
          ? Address.fromJson(map['workAddress'] as Map<String, dynamic>)
          : null,
      previousAddresses: (map['previousAddresses'] as List<dynamic>?)
              ?.map((e) => Address.fromJson(e as Map<String, dynamic>))
              .toList()
              .cast<Address>() ??
          [],
      namedAddresses: (map['namedAddresses'] as Map<String, Address>?),
      primaryContact: Contact.fromJson(
          (map['primaryContact'] ?? {}) as Map<String, dynamic>),
      contacts: (map['contacts'] as List<dynamic>?)
          ?.map((e) => Contact.fromJson(e as Map<String, dynamic>))
          .toList()
          .cast<Contact>(),
      employer: map['employer'] != null
          ? Company.fromJson(map['employer'] as Map<String, dynamic>)
          : null,
      customAddress: NestedObjects._readValue(map, 'customAddress') as Address?,
      parsedContacts:
          NestedObjects._readValue(map, 'parsedContacts') as List<Contact>?,
    );
  }
}
