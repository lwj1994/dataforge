// Generated by data class generator
// DO NOT MODIFY BY HAND

part of 'default_values.dart';

mixin _DefaultValues {
  abstract final int intValue;
  abstract final String stringValue;
  abstract final bool boolValue;
  abstract final double doubleValue;
  abstract final List<String> listValue;

  DefaultValues copyWith({
    int? intValue,
    String? stringValue,
    bool? boolValue,
    double? doubleValue,
    List<String>? listValue,
  }) {
    return DefaultValues(
      intValue: intValue ?? this.intValue,
      stringValue: stringValue ?? this.stringValue,
      boolValue: boolValue ?? this.boolValue,
      doubleValue: doubleValue ?? this.doubleValue,
      listValue: listValue ?? this.listValue,
    );
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (other is! DefaultValues) return false;

    if (intValue != other.intValue) {
      return false;
    }
    if (stringValue != other.stringValue) {
      return false;
    }
    if (boolValue != other.boolValue) {
      return false;
    }
    if (doubleValue != other.doubleValue) {
      return false;
    }
    if (!const DeepCollectionEquality().equals(listValue, other.listValue)) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    return Object.hashAll([
      intValue,
      stringValue,
      boolValue,
      doubleValue,
      const DeepCollectionEquality().hash(listValue),
    ]);
  }
  @override
  String toString() {
    return 'DefaultValues(intValue: $intValue, stringValue: $stringValue, boolValue: $boolValue, doubleValue: $doubleValue, listValue: $listValue)';
  }


  Map<String, dynamic> toJson() {
    final map = <String, dynamic>{};
    map['intValue'] = intValue;
    map['stringValue'] = stringValue;
    map['boolValue'] = boolValue;
    map['doubleValue'] = doubleValue;
    map['listValue'] = listValue;
    return map;
  }

  static DefaultValues fromJson(Map<String, dynamic> map) {
    return DefaultValues(
      intValue: int.tryParse((map['intValue'] ?? '').toString()) ?? 42,
      stringValue: (map['stringValue'])?.toString() ?? 'default',
      boolValue: (map['boolValue'] as bool?) ?? true,
      doubleValue: double.tryParse((map['doubleValue'] ?? '').toString()) ?? 3.14,
      listValue: (map['listValue'] as List<dynamic>?)?.map((e) => e.toString()).toList() ?? const ['default'],
    );
  }
}

mixin _NestedDefaultValues {
  abstract final String name;
  abstract final DefaultValues nested;
  abstract final int? nullableValue;

  NestedDefaultValues copyWith({
    String? name,
    DefaultValues? nested,
    int? nullableValue,
  }) {
    return NestedDefaultValues(
      name: name ?? this.name,
      nested: nested ?? this.nested,
      nullableValue: nullableValue ?? this.nullableValue,
    );
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (other is! NestedDefaultValues) return false;

    if (name != other.name) {
      return false;
    }
    if (nested != other.nested) {
      return false;
    }
    if (nullableValue != other.nullableValue) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    return Object.hashAll([
      name,
      nested,
      nullableValue,
    ]);
  }
  @override
  String toString() {
    return 'NestedDefaultValues(name: $name, nested: $nested, nullableValue: $nullableValue)';
  }


  Map<String, dynamic> toJson() {
    final map = <String, dynamic>{};
    map['name'] = name;
    map['nested'] = nested;
    map['nullableValue'] = nullableValue;
    return map;
  }

  static NestedDefaultValues fromJson(Map<String, dynamic> map) {
    return NestedDefaultValues(
      name: (map['name'])?.toString() ?? 'nested_default',
      nested: map['nested'] != null ? DefaultValues.fromJson(map['nested'] as Map<String, dynamic>) : const DefaultValues(),
      nullableValue: map['nullableValue'] != null ? int.tryParse(map['nullableValue'].toString()) : null,
    );
  }
}

