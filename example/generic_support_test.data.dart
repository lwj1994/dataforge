// Generated by data class generator
// DO NOT MODIFY BY HAND

part of 'generic_support_test.dart';

mixin _GenericPair<T, U> {
  abstract final T first;
  abstract final U second;

  GenericPair<T, U> copyWith({
    T? first,
    U? second,
  }) {
    return GenericPair<T, U>(
      first: first ?? this.first,
      second: second ?? this.second,
    );
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (other is! GenericPair) return false;

    if (first != other.first) {
      return false;
    }
    if (second != other.second) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    return Object.hashAll([
      first,
      second,
    ]);
  }

  @override
  String toString() {
    return 'GenericPair(first: $first, second: $second)';
  }

  Map<String, dynamic> toJson() {
    final map = <String, dynamic>{};
    map['first'] = first;
    map['second'] = second;
    return map;
  }

  static GenericPair<T, U> fromJson<T, U>(Map<String, dynamic> map) {
    return GenericPair<T, U>(
      first: map['first'] as T,
      second: map['second'] as U,
    );
  }
}

mixin _GenericWrapper<T> {
  abstract final T value;
  abstract final String label;

  GenericWrapper<T> copyWith({
    T? value,
    String? label,
  }) {
    return GenericWrapper<T>(
      value: value ?? this.value,
      label: label ?? this.label,
    );
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (other is! GenericWrapper) return false;

    if (value != other.value) {
      return false;
    }
    if (label != other.label) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    return Object.hashAll([
      value,
      label,
    ]);
  }

  @override
  String toString() {
    return 'GenericWrapper(value: $value, label: $label)';
  }

  Map<String, dynamic> toJson() {
    final map = <String, dynamic>{};
    map['value'] = value;
    map['label'] = label;
    return map;
  }

  static GenericWrapper<T> fromJson<T>(Map<String, dynamic> map) {
    return GenericWrapper<T>(
      value: map['value'] as T,
      label: (map['label'])?.toString() ?? "",
    );
  }
}

mixin _GenericBounded<T extends num> {
  abstract final T number;
  abstract final String description;

  GenericBounded<T> copyWith({
    T? number,
    String? description,
  }) {
    return GenericBounded<T>(
      number: number ?? this.number,
      description: description ?? this.description,
    );
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (other is! GenericBounded) return false;

    if (number != other.number) {
      return false;
    }
    if (description != other.description) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    return Object.hashAll([
      number,
      description,
    ]);
  }

  @override
  String toString() {
    return 'GenericBounded(number: $number, description: $description)';
  }

  Map<String, dynamic> toJson() {
    final map = <String, dynamic>{};
    map['number'] = number;
    map['description'] = description;
    return map;
  }

  static GenericBounded<T> fromJson<T extends num>(Map<String, dynamic> map) {
    return GenericBounded<T>(
      number: map['number'] as T,
      description: (map['description'])?.toString() ?? "",
    );
  }
}

mixin _GenericWithFeatures<T> {
  abstract final T data;
  abstract final List<String> tags;
  abstract final Map<String, dynamic> metadata;
  abstract final DateTime createdAt;
  abstract final TestStatus status;
  abstract final Duration? timeout;

  GenericWithFeatures<T> copyWith({
    T? data,
    List<String>? tags,
    Map<String, dynamic>? metadata,
    DateTime? createdAt,
    TestStatus? status,
    Duration? timeout,
  }) {
    return GenericWithFeatures<T>(
      data: data ?? this.data,
      tags: tags ?? this.tags,
      metadata: metadata ?? this.metadata,
      createdAt: createdAt ?? this.createdAt,
      status: status ?? this.status,
      timeout: timeout ?? this.timeout,
    );
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (other is! GenericWithFeatures) return false;

    if (data != other.data) {
      return false;
    }
    if (!DeepCollectionEquality().equals(tags, other.tags)) {
      return false;
    }
    if (!DeepCollectionEquality().equals(metadata, other.metadata)) {
      return false;
    }
    if (createdAt != other.createdAt) {
      return false;
    }
    if (status != other.status) {
      return false;
    }
    if (timeout != other.timeout) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    return Object.hashAll([
      data,
      DeepCollectionEquality().hash(tags),
      DeepCollectionEquality().hash(metadata),
      createdAt,
      status,
      timeout,
    ]);
  }

  @override
  String toString() {
    return 'GenericWithFeatures(data: $data, tags: $tags, metadata: $metadata, createdAt: $createdAt, status: $status, timeout: $timeout)';
  }

  Map<String, dynamic> toJson() {
    final map = <String, dynamic>{};
    map['data'] = data;
    map['tags'] = tags;
    map['metadata'] = metadata;
    map['createdAt'] = const DateTimeConverter().toJson(createdAt);
    map['status'] = const EnumConverter(TestStatus.values).toJson(status);
    if (timeout != null) {
      map['timeout'] =
          timeout != null ? const DurationConverter().toJson(timeout!) : null;
    }
    return map;
  }

  static GenericWithFeatures<T> fromJson<T>(Map<String, dynamic> map) {
    return GenericWithFeatures<T>(
      data: map['data'] as T,
      tags: ((map['tags'] as List<dynamic>?) ?? [])
          .map((e) => e.toString())
          .toList(),
      metadata: (map['metadata'] as Map<String, dynamic>?) ?? {},
      createdAt: map['createdAt'] != null
          ? const DateTimeConverter().fromJson(map['createdAt'])
          : throw ArgumentError('Required field createdAt is missing'),
      status: map['status'] != null
          ? const EnumConverter(TestStatus.values).fromJson(map['status'])
          : throw ArgumentError('Required field status is missing'),
      timeout: map['timeout'] != null
          ? const DurationConverter().fromJson(map['timeout'])
          : null,
    );
  }
}
