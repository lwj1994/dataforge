// Generated by data class generator
// DO NOT MODIFY BY HAND

part of 'auto_type_matching_example.dart';

mixin _AutoMatchingExample {
  abstract final DateTime createdAt;
  abstract final DateTime? updatedAt;
  abstract final Duration processingTime;
  abstract final Duration? timeout;
  abstract final Priority priority;
  abstract final Status? status;
  abstract final String title;
  abstract final int count;
  abstract final double price;
  abstract final bool isActive;
  abstract final DateTime timestampField;
  abstract final Priority indexBasedPriority;

  AutoMatchingExample copyWith({
    DateTime? createdAt,
    DateTime? updatedAt,
    Duration? processingTime,
    Duration? timeout,
    Priority? priority,
    Status? status,
    String? title,
    int? count,
    double? price,
    bool? isActive,
    DateTime? timestampField,
    Priority? indexBasedPriority,
  }) {
    return AutoMatchingExample(
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
      processingTime: processingTime ?? this.processingTime,
      timeout: timeout ?? this.timeout,
      priority: priority ?? this.priority,
      status: status ?? this.status,
      title: title ?? this.title,
      count: count ?? this.count,
      price: price ?? this.price,
      isActive: isActive ?? this.isActive,
      timestampField: timestampField ?? this.timestampField,
      indexBasedPriority: indexBasedPriority ?? this.indexBasedPriority,
    );
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (other is! AutoMatchingExample) return false;

    if (createdAt != other.createdAt) {
      return false;
    }
    if (updatedAt != other.updatedAt) {
      return false;
    }
    if (processingTime != other.processingTime) {
      return false;
    }
    if (timeout != other.timeout) {
      return false;
    }
    if (priority != other.priority) {
      return false;
    }
    if (status != other.status) {
      return false;
    }
    if (title != other.title) {
      return false;
    }
    if (count != other.count) {
      return false;
    }
    if (price != other.price) {
      return false;
    }
    if (isActive != other.isActive) {
      return false;
    }
    if (timestampField != other.timestampField) {
      return false;
    }
    if (indexBasedPriority != other.indexBasedPriority) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    return Object.hashAll([
      createdAt,
      updatedAt,
      processingTime,
      timeout,
      priority,
      status,
      title,
      count,
      price,
      isActive,
      timestampField,
      indexBasedPriority,
    ]);
  }

  @override
  String toString() {
    return 'AutoMatchingExample(createdAt: $createdAt, updatedAt: $updatedAt, processingTime: $processingTime, timeout: $timeout, priority: $priority, status: $status, title: $title, count: $count, price: $price, isActive: $isActive, timestampField: $timestampField, indexBasedPriority: $indexBasedPriority)';
  }

  Map<String, dynamic> toJson() {
    final map = <String, dynamic>{};
    map['createdAt'] = const DateTimeConverter().toJson(createdAt);
    if (updatedAt != null) {
      map['updatedAt'] = updatedAt != null
          ? const DateTimeConverter().toJson(updatedAt!)
          : null;
    }
    map['processingTime'] = const DurationConverter().toJson(processingTime);
    if (timeout != null) {
      map['timeout'] =
          timeout != null ? const DurationConverter().toJson(timeout!) : null;
    }
    map['priority'] = const EnumConverter(Priority.values).toJson(priority);
    if (status != null) {
      map['status'] = status != null
          ? const EnumConverter(Status.values).toJson(status!)
          : null;
    }
    map['title'] = title;
    map['count'] = count;
    map['price'] = price;
    map['isActive'] = isActive;
    map['timestampField'] =
        const DateTimeMillisecondsConverter().toJson(timestampField);
    map['indexBasedPriority'] =
        const EnumIndexConverter<Priority>(Priority.values)
            .toJson(indexBasedPriority);
    return map;
  }

  static AutoMatchingExample fromJson(Map<String, dynamic> map) {
    return AutoMatchingExample(
      createdAt: map['createdAt'] != null
          ? const DateTimeConverter().fromJson(map['createdAt'])
          : throw ArgumentError('Required field createdAt is missing'),
      updatedAt: map['updatedAt'] != null
          ? const DateTimeConverter().fromJson(map['updatedAt'])
          : null,
      processingTime: map['processingTime'] != null
          ? const DurationConverter().fromJson(map['processingTime'])
          : throw ArgumentError('Required field processingTime is missing'),
      timeout: map['timeout'] != null
          ? const DurationConverter().fromJson(map['timeout'])
          : null,
      priority: map['priority'] != null
          ? const EnumConverter(Priority.values).fromJson(map['priority'])
          : throw ArgumentError('Required field priority is missing'),
      status: map['status'] != null
          ? const EnumConverter(Status.values).fromJson(map['status'])
          : null,
      title: (map['title'])?.toString() ?? "",
      count: int.tryParse((map['count'] ?? '').toString()) ?? 0,
      price: double.tryParse((map['price'] ?? '').toString()) ?? 0.0,
      isActive: (map['isActive'] as bool?) ?? false,
      timestampField: map['timestampField'] != null
          ? const DateTimeMillisecondsConverter()
              .fromJson(map['timestampField'])
          : throw ArgumentError('Required field timestampField is missing'),
      indexBasedPriority: map['indexBasedPriority'] != null
          ? const EnumIndexConverter<Priority>(Priority.values)
              .fromJson(map['indexBasedPriority'])
          : throw ArgumentError('Required field indexBasedPriority is missing'),
    );
  }
}
