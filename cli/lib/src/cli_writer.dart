import 'dart:io';

import 'package:dataforge_base/src/model.dart';
import 'package:dataforge_base/src/writer.dart';

class CliWriter {
  final ParseResult result;
  final String? projectRoot;
  final bool debugMode;
  final String? _dataforgeAnnotationPrefix;
  final Set<String> _enumTypeCache = {};

  CliWriter(this.result, {this.projectRoot, this.debugMode = false})
      : _dataforgeAnnotationPrefix = _getDataforgeAnnotationPrefix(result);

  Future<String> writeCodeAsync() async {
    final writeStartTime = DateTime.now();
    if (debugMode) {
      print(
          '[PERF] $writeStartTime: Starting writeCodeAsync() for ${result.outputPath}');
    }

    // Pre-process classes to inject prefix and heuristics results
    final updatedClasses = <ClassInfo>[];
    for (final clazz in result.classes) {
      final updatedFields = <FieldInfo>[];
      for (final field in clazz.fields) {
        final cleanType =
            _removeGenericParameters(field.type.replaceAll('?', ''));

        bool isEnum = field.isEnum;
        if (!isEnum) {
          isEnum = _isEnumType(cleanType);
        }

        bool isDataforge = field.isDataforge;
        if (!isDataforge) {
          // Heuristic: if it looks like a custom class (has fromJson), treat as Dataforge
          isDataforge = _hasFromJsonMethod(field.type);
        }

        bool isInnerEnum = field.isInnerEnum;
        if (!isInnerEnum &&
            (field.type.startsWith('List<') || field.type.startsWith('Map<'))) {
          final innerType = field.type
              .substring(
                  field.type.indexOf('<') + 1, field.type.lastIndexOf('>'))
              .split(',')
              .last
              .replaceAll('?', '')
              .trim();
          isInnerEnum = _isEnumType(innerType);
        }

        bool isInnerDataforge = field.isInnerDataforge;
        if (!isInnerDataforge &&
            (field.type.startsWith('List<') || field.type.startsWith('Map<'))) {
          final innerType = field.type
              .substring(
                  field.type.indexOf('<') + 1, field.type.lastIndexOf('>'))
              .split(',')
              .last
              .replaceAll('?', '')
              .trim();
          isInnerDataforge = _hasFromJsonMethod(innerType);
        }

        updatedFields.add(field.copyWith(
          isEnum: isEnum,
          isDataforge: isDataforge,
          isInnerEnum: isInnerEnum,
          isInnerDataforge: isInnerDataforge,
        ));
      }

      updatedClasses.add(clazz.copyWith(
        fields: updatedFields,
        dataforgePrefix: _dataforgeAnnotationPrefix,
      ));
    }

    final updatedResult = ParseResult(
        result.outputPath, result.partOf, updatedClasses, result.imports,
        primaryClassName: result.primaryClassName);

    // Generate content using shared GeneratorWriter
    final generator = GeneratorWriter(updatedResult);
    final buffer = StringBuffer();

    buffer.writeln('// Generated by data class generator');
    buffer.writeln('// DO NOT MODIFY BY HAND\n');
    buffer.writeln(result.partOf);
    buffer.writeln();

    buffer.write(generator.generate());

    final fileWriteStartTime = DateTime.now();

    final file = File(result.outputPath);
    await file.create(recursive: true);
    await file.writeAsString(buffer.toString());

    final fileWriteEndTime = DateTime.now();
    if (debugMode) {
      print(
          '[PERF] $fileWriteEndTime: File write completed in ${fileWriteEndTime.difference(fileWriteStartTime).inMilliseconds}ms');
    }

    await _processOriginalFilesAsync();

    return result.outputPath;
  }

  /// Get the prefix for dataforge_annotation based on import statements
  static String? _getDataforgeAnnotationPrefix(ParseResult result) {
    for (final import in result.imports) {
      if (import.uri ==
              'package:dataforge_annotation/dataforge_annotation.dart' &&
          import.alias != null) {
        return import.alias;
      }
    }
    return null; // No prefix needed if no alias is used
  }

  /// Check if a type is an enum by analyzing the source files
  bool _isEnumType(String type) {
    // Remove nullable marker and generic parameters
    final cleanType = _removeGenericParameters(type.replaceAll('?', ''));
    if (_enumTypeCache.contains(cleanType)) {
      return true;
    }

    // Use project root if available, otherwise fall back to current directory
    final searchDir =
        projectRoot != null ? Directory(projectRoot!) : Directory.current;
    if (!searchDir.existsSync()) {
      return false;
    }

    // Check all Dart files in the search directory for enum definitions
    // Optimized: Only search if not primitive
    const primitives = {
      'int',
      'double',
      'String',
      'bool',
      'num',
      'dynamic',
      'void',
      'Object',
      'DateTime',
      'Duration',
      'Uri'
    };
    if (primitives.contains(cleanType)) return false;

    final dartFiles = searchDir
        .listSync(recursive: true)
        .whereType<File>()
        .where((file) => file.path.endsWith('.dart'))
        .toList();

    for (final file in dartFiles) {
      try {
        final content = file.readAsStringSync();

        // Look for enum definition
        final enumPattern =
            RegExp(r'enum\s+' + RegExp.escape(cleanType) + r'\s*\{');
        if (enumPattern.hasMatch(content)) {
          _enumTypeCache.add(cleanType);
          return true;
        }
      } catch (e) {
        // Ignore file read errors
        continue;
      }
    }
    return false;
  }

  /// Check if a type has a fromJson method (heuristic: assume custom classes do)
  bool _hasFromJsonMethod(String type) {
    // Primitive types don't have fromJson
    const primitiveTypes = {
      'String',
      'int',
      'double',
      'bool',
      'num',
      'Object',
      'dynamic',
      'DateTime',
      'Duration',
      'Uri',
      'BigInt'
    };
    final cleanType = _removeGenericParameters(type.replaceAll('?', ''));
    if (primitiveTypes.contains(cleanType)) return false;
    if (cleanType == 'List' ||
        cleanType == 'Map' ||
        cleanType.startsWith('List<') ||
        cleanType.startsWith('Map<')) return false;
    // Assume other types (custom classes) have fromJson
    return true;
  }

  /// Remove generic parameters from a type string, handling nested generics correctly
  String _removeGenericParameters(String type) {
    if (!type.contains('<')) {
      return type;
    }

    final buffer = StringBuffer();
    int depth = 0;

    for (int i = 0; i < type.length; i++) {
      final char = type[i];

      if (char == '<') {
        depth++;
      } else if (char == '>') {
        depth--;
      } else if (depth == 0) {
        buffer.write(char);
      }
    }

    return buffer.toString();
  }

  /// Process original files asynchronously
  Future<void> _processOriginalFilesAsync() async {
    // Infer original file path from output path
    final originalFilePath =
        result.outputPath.replaceAll('.data.dart', '.dart');

    await _batchProcessOriginalFileAsync(originalFilePath);
  }

  /// Batch process all file modifications in a single read-write operation (async)
  Future<void> _batchProcessOriginalFileAsync(String filePath) async {
    try {
      final file = File(filePath);
      if (!await file.exists()) return;

      final content = await file.readAsString();
      final lines = content.split('\n');
      bool modified = false;

      final dataFileName = result.outputPath.split('/').last;

      // Step 1: Add collection import if needed
      if (!_hasCollectionImport(lines)) {
        _insertCollectionImport(lines);
        modified = true;
      }

      // Step 2: Add part declaration if needed
      if (!_hasPartDeclarationInLines(lines, dataFileName)) {
        _insertPartDeclaration(lines, dataFileName);
        modified = true;
      }

      // Step 3: Process all classes in batch
      for (final clazz in result.classes) {
        // Add with clause to class declaration
        if (_addWithClauseToLines(lines, clazz.name)) {
          modified = true;
        }

        // Add fromJson method if needed
        if (clazz.includeFromJson &&
            !_hasFromJsonMethodInLines(lines, clazz.name)) {
          if (_addFromJsonToLines(lines, clazz.name)) {
            modified = true;
          }
        }
      }

      // Write back to file only if modifications were made
      if (modified) {
        await file.writeAsString(lines.join('\n'));
      }
    } catch (e) {
      if (debugMode) print('Error in batch processing $filePath: $e');
    }
  }

  /// Check if collection import exists in lines
  bool _hasCollectionImport(List<String> lines) {
    return lines.any((line) =>
        line.trim().startsWith("import 'package:collection/collection.dart'") ||
        line.trim().startsWith('import "package:collection/collection.dart"'));
  }

  /// Insert collection import into lines
  void _insertCollectionImport(List<String> lines) {
    // Find the last import statement that ends with semicolon
    int lastImportIndex = -1;

    for (int i = 0; i < lines.length; i++) {
      final line = lines[i].trim();
      // Check if line starts with import and ends with semicolon
      if (line.startsWith('import ') && line.endsWith(';')) {
        lastImportIndex = i;
      }
    }

    // Insert collection import after the last import
    if (lastImportIndex >= 0) {
      lines.insert(
          lastImportIndex + 1, "import 'package:collection/collection.dart';");
    } else {
      // If no imports found, insert at the beginning
      lines.insert(0, "import 'package:collection/collection.dart';");
    }
  }

  /// Check if part declaration exists in lines
  bool _hasPartDeclarationInLines(List<String> lines, String dataFileName) {
    final partDeclaration1 = "part '$dataFileName';";
    final partDeclaration2 = 'part "$dataFileName";';

    return lines.any((line) {
      final trimmed = line.trim();
      return trimmed == partDeclaration1 || trimmed == partDeclaration2;
    });
  }

  /// Insert part declaration into lines
  void _insertPartDeclaration(List<String> lines, String dataFileName) {
    // Find the position to insert part declaration (after imports)
    int insertIndex = 0;
    bool foundImports = false;

    for (int i = 0; i < lines.length; i++) {
      final line = lines[i].trim();

      // Skip empty lines and comments at the beginning
      if (line.isEmpty || line.startsWith('//') || line.startsWith('/*')) {
        continue;
      }

      // If it's an import or export, mark that we found imports
      if (line.startsWith('import ') || line.startsWith('export ')) {
        foundImports = true;
        insertIndex = i + 1;
      } else if (foundImports &&
          !line.startsWith('import ') &&
          !line.startsWith('export ')) {
        // We've passed all imports, this is where we insert
        break;
      } else if (!foundImports) {
        // No imports found, insert at the beginning (after initial comments)
        insertIndex = i;
        break;
      }
    }

    // Insert part declaration
    final partDeclaration = "part '$dataFileName';";

    // Add empty line before part if there are imports
    if (foundImports &&
        insertIndex > 0 &&
        lines[insertIndex - 1].trim().isNotEmpty) {
      lines.insert(insertIndex, '');
      insertIndex++;
    }

    lines.insert(insertIndex, partDeclaration);

    // Add empty line after part if the next line is not empty
    if (insertIndex + 1 < lines.length &&
        lines[insertIndex + 1].trim().isNotEmpty) {
      lines.insert(insertIndex + 1, '');
    }
  }

  /// Add with clause to class in lines, returns true if modified
  bool _addWithClauseToLines(List<String> lines, String className) {
    for (int i = 0; i < lines.length; i++) {
      final line = lines[i];

      // Find class declaration line
      final classPattern =
          RegExp(r'\bclass\s+' + RegExp.escape(className) + r'\b');
      if (classPattern.hasMatch(line) && !line.contains('mixin')) {
        String genericPart = '';
        final genericStartIndex = line.indexOf('<');

        // Check for presence of generics and that it's part of the class name
        final classDefRegex =
            RegExp('^\\s*(abstract\\s+)?class\\s+$className\\s*<');
        if (genericStartIndex != -1 && classDefRegex.hasMatch(line)) {
          int depth = 0;
          int genericEndIndex = -1;
          for (int j = genericStartIndex; j < line.length; j++) {
            if (line[j] == '<') {
              depth++;
            } else if (line[j] == '>') {
              depth--;
              if (depth == 0) {
                genericEndIndex = j;
                break;
              }
            }
          }
          if (genericEndIndex != -1) {
            genericPart =
                line.substring(genericStartIndex, genericEndIndex + 1);
          }
        }

        final mixinName = '_$className$genericPart';
        final trimmedLine = line.trim();

        // Check if already has the correct with clause
        final mixinPattern = RegExp('\\b${RegExp.escape(mixinName)}\\b');
        if (mixinPattern.hasMatch(trimmedLine)) {
          return false; // Already has the correct with clause
        }

        // Check if has any with clause
        if (trimmedLine.contains(' with ')) {
          // Has existing with clause, add our mixin
          final withIndex = line.indexOf(' with ');
          final openBraceIndex = line.indexOf('{');

          if (openBraceIndex > withIndex) {
            // Insert before the opening brace
            final beforeBrace = line.substring(0, openBraceIndex).trim();
            final afterBrace = line.substring(openBraceIndex);
            lines[i] = '$beforeBrace, $mixinName $afterBrace';
            return true;
          }
        } else {
          // No existing with clause, add one
          final openBraceIndex = line.indexOf('{');

          if (openBraceIndex != -1) {
            final beforeBrace = line.substring(0, openBraceIndex).trim();
            final afterBrace = line.substring(openBraceIndex);
            lines[i] = '$beforeBrace with $mixinName $afterBrace';
            return true;
          }
        }
        break;
      }
    }
    return false;
  }

  /// Check if fromJson method exists in lines
  bool _hasFromJsonMethodInLines(List<String> lines, String className) {
    final fromJsonPattern = RegExp(
      'factory\\s+$className\\.fromJson\\s*\\(',
      multiLine: true,
    );
    return lines.any((line) => fromJsonPattern.hasMatch(line));
  }

  /// Add fromJson method to lines, returns true if modified
  bool _addFromJsonToLines(List<String> lines, String className) {
    // Find the end position of class definition (before the last })
    int insertIndex = -1;
    int braceCount = 0;
    bool inClass = false;

    for (int i = 0; i < lines.length; i++) {
      final line = lines[i].trim();

      // Check if we've entered the target class
      final classPattern =
          RegExp(r'\bclass\s+' + RegExp.escape(className) + r'\b');
      if (!inClass && classPattern.hasMatch(line) && !line.contains('mixin')) {
        inClass = true;
      }

      if (inClass) {
        // Count braces
        braceCount += '{'.allMatches(line).length;
        braceCount -= '}'.allMatches(line).length;

        // When braces are balanced, class definition ends
        if (braceCount == 0 && line.contains('}')) {
          insertIndex = i;
          break;
        }
      }
    }

    if (insertIndex != -1) {
      // Insert fromJson method before the last } of the class
      final fromJsonMethod = '''
  factory $className.fromJson(Map<String, dynamic> json) {
    return _$className.fromJson(json);
  }
''';
      lines.insert(insertIndex, fromJsonMethod);
      return true;
    }
    return false;
  }
}
